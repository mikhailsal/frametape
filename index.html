<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Game ‚Äî AI Vision Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a1a;
      color: #e0e0e0;
      font-family: 'Segoe UI', 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    #game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 400px;
    }

    #game-title {
      font-size: 24px;
      font-weight: bold;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
    }

    #score-display {
      font-size: 20px;
      color: #ffaa00;
      font-weight: bold;
    }

    #game-canvas {
      border: 2px solid #00ff88;
      border-radius: 4px;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.15);
      background: #111;
    }

    #game-message {
      font-size: 16px;
      color: #888;
      text-align: center;
      height: 24px;
    }

    #game-message.game-over {
      color: #ff4444;
      font-weight: bold;
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    #controls-info {
      font-size: 12px;
      color: #555;
      text-align: center;
    }
  </style>
</head>
<body>
  <!-- Load FrameTape AI Debug Library FIRST -->
  <script src="frametape.js"></script>

  <div id="game-container">
    <div id="game-header">
      <div id="game-title">üêç SNAKE</div>
      <div id="score-display">Score: 0</div>
    </div>
    <canvas id="game-canvas" width="400" height="400"></canvas>
    <div id="game-message">Press any arrow key to start</div>
    <div id="controls-info">Arrow keys to move | R to restart</div>
  </div>

  <script>
    (function () {
      'use strict';

      // ============================================================
      // Game Configuration
      // ============================================================
      const GRID_SIZE = 20;       // 20x20 grid
      const CELL_SIZE = 20;       // 20px per cell = 400px canvas
      const TICK_RATE = 8;        // moves per second (normal mode)
      const CANVAS_SIZE = GRID_SIZE * CELL_SIZE;

      // ============================================================
      // Canvas Setup
      // ============================================================
      const canvas = document.getElementById('game-canvas');
      const ctx = canvas.getContext('2d');
      const scoreDisplay = document.getElementById('score-display');
      const messageDisplay = document.getElementById('game-message');

      // ============================================================
      // Game State (centralized, serializable)
      // ============================================================
      // ============================================================
      // Mirror Doppelg√§nger Configuration
      // ============================================================
      const MIRROR_FOOD_MIN_INTERVAL = 10;  // game moves (min moves between mirror food spawns)
      const MIRROR_FOOD_MAX_INTERVAL = 10;  // game moves (max moves between mirror food spawns)
      const DOPPELGANGER_MIN_DURATION = 10; // seconds
      const DOPPELGANGER_MAX_DURATION = 15; // seconds

      function createInitialState() {
        const centerX = Math.floor(GRID_SIZE / 2);
        const centerY = Math.floor(GRID_SIZE / 2);
        return {
          snake: [
            { x: centerX, y: centerY },
            { x: centerX - 1, y: centerY },
            { x: centerX - 2, y: centerY },
          ],
          direction: 'right',
          nextDirection: 'right',
          food: null,          // will be placed on first update
          score: 0,
          gameOver: false,
          started: false,
          tickCounter: 0,      // counts animation frames
          moveCounter: 0,      // counts snake moves
          gridSize: GRID_SIZE,
          cellSize: CELL_SIZE,
          tickRate: TICK_RATE,

          // Mirror Doppelg√§nger state
          mirrorFood: null,              // { x, y } ‚Äî special mirror food position
          mirrorFoodTimer: 0,            // ticks until next mirror food spawn
          mirrorFoodSpawnInterval: 0,    // chosen interval in ticks
          doppelganger: {
            active: false,
            segments: [],                // mirrored snake segments
            remainingTicks: 0,           // ticks until doppelg√§nger disappears
            totalDurationTicks: 0,       // total duration for display purposes
          },
        };
      }

      let state = createInitialState();

      // ============================================================
      // Food Placement
      // ============================================================
      function getOccupiedSet(state) {
        const occupied = new Set(state.snake.map(s => `${s.x},${s.y}`));
        if (state.food) occupied.add(`${state.food.x},${state.food.y}`);
        if (state.mirrorFood) occupied.add(`${state.mirrorFood.x},${state.mirrorFood.y}`);
        if (state.doppelganger && state.doppelganger.active) {
          state.doppelganger.segments.forEach(s => occupied.add(`${s.x},${s.y}`));
        }
        return occupied;
      }

      function placeFood(state) {
        const occupied = getOccupiedSet(state);
        let attempts = 0;
        let x, y;
        do {
          x = Math.floor(Math.random() * GRID_SIZE);
          y = Math.floor(Math.random() * GRID_SIZE);
          attempts++;
        } while (occupied.has(`${x},${y}`) && attempts < 1000);

        return { x, y };
      }

      // ============================================================
      // Mirror Food Placement
      // ============================================================
      function placeMirrorFood(state) {
        const occupied = getOccupiedSet(state);
        let attempts = 0;
        let x, y;
        do {
          x = Math.floor(Math.random() * GRID_SIZE);
          y = Math.floor(Math.random() * GRID_SIZE);
          attempts++;
        } while (occupied.has(`${x},${y}`) && attempts < 1000);

        return { x, y };
      }

      function getRandomMirrorFoodInterval() {
        // Returns interval directly in game moves
        const moves = MIRROR_FOOD_MIN_INTERVAL +
          Math.random() * (MIRROR_FOOD_MAX_INTERVAL - MIRROR_FOOD_MIN_INTERVAL);
        return Math.round(moves);
      }

      function getRandomDoppelgangerDuration() {
        // Returns duration in game moves
        const seconds = DOPPELGANGER_MIN_DURATION +
          Math.random() * (DOPPELGANGER_MAX_DURATION - DOPPELGANGER_MIN_DURATION);
        return Math.round(seconds * TICK_RATE);
      }

      // Compute mirrored segments (symmetrical to center of the grid)
      function computeMirrorSegments(snake) {
        return snake.map(function (seg) {
          return {
            x: GRID_SIZE - 1 - seg.x,
            y: GRID_SIZE - 1 - seg.y,
          };
        });
      }

      // ============================================================
      // Game Logic: Update
      // ============================================================
      function update(state) {
        if (state.gameOver || !state.started) return state;

        state.tickCounter++;

        // Only move the snake every N frames (based on tick rate)
        // At 60fps with TICK_RATE=8, move every ~7.5 frames
        const framesPerMove = Math.round(60 / state.tickRate);
        if (state.tickCounter % framesPerMove !== 0) return state;

        state.moveCounter++;

        // --- Mirror Food Spawn Timer ---
        if (!state.mirrorFood && !state.doppelganger.active) {
          if (state.mirrorFoodSpawnInterval === 0) {
            // Initialize the timer on first move
            state.mirrorFoodSpawnInterval = getRandomMirrorFoodInterval();
            state.mirrorFoodTimer = state.mirrorFoodSpawnInterval;
          }
          state.mirrorFoodTimer--;
          if (state.mirrorFoodTimer <= 0) {
            state.mirrorFood = placeMirrorFood(state);
            state.mirrorFoodTimer = 0;
          }
        }

        // --- Doppelg√§nger Countdown ---
        if (state.doppelganger.active) {
          state.doppelganger.remainingTicks--;
          if (state.doppelganger.remainingTicks <= 0) {
            // Deactivate doppelg√§nger
            state.doppelganger.active = false;
            state.doppelganger.segments = [];
            state.doppelganger.remainingTicks = 0;
            state.doppelganger.totalDurationTicks = 0;
            // Schedule next mirror food
            state.mirrorFoodSpawnInterval = getRandomMirrorFoodInterval();
            state.mirrorFoodTimer = state.mirrorFoodSpawnInterval;
          }
        }

        // Apply direction change
        state.direction = state.nextDirection;

        // Calculate new head position
        const head = state.snake[0];
        let newHead;
        switch (state.direction) {
          case 'up':    newHead = { x: head.x, y: head.y - 1 }; break;
          case 'down':  newHead = { x: head.x, y: head.y + 1 }; break;
          case 'left':  newHead = { x: head.x - 1, y: head.y }; break;
          case 'right': newHead = { x: head.x + 1, y: head.y }; break;
        }

        // Wall collision
        if (newHead.x < 0 || newHead.x >= GRID_SIZE ||
            newHead.y < 0 || newHead.y >= GRID_SIZE) {
          state.gameOver = true;
          return state;
        }

        // Self collision (check against all body segments except the tail,
        // because the tail will move away)
        for (let i = 0; i < state.snake.length - 1; i++) {
          if (state.snake[i].x === newHead.x && state.snake[i].y === newHead.y) {
            state.gameOver = true;
            return state;
          }
        }

        // Doppelg√§nger collision (it's solid, like a wall)
        if (state.doppelganger.active) {
          for (let i = 0; i < state.doppelganger.segments.length; i++) {
            const seg = state.doppelganger.segments[i];
            if (seg.x === newHead.x && seg.y === newHead.y) {
              state.gameOver = true;
              return state;
            }
          }
        }

        // Move snake
        state.snake.unshift(newHead);

        // Check regular food
        if (state.food && newHead.x === state.food.x && newHead.y === state.food.y) {
          // Double points when doppelg√§nger is active!
          state.score += state.doppelganger.active ? 2 : 1;
          state.food = placeFood(state);
          // Don't remove tail ‚Äî snake grows
        } else {
          state.snake.pop(); // Remove tail
        }

        // Check mirror food ‚Äî activates the doppelg√§nger
        if (state.mirrorFood && newHead.x === state.mirrorFood.x && newHead.y === state.mirrorFood.y) {
          state.mirrorFood = null;
          const duration = getRandomDoppelgangerDuration();
          state.doppelganger.active = true;
          state.doppelganger.remainingTicks = duration;
          state.doppelganger.totalDurationTicks = duration;
          state.doppelganger.segments = computeMirrorSegments(state.snake);
        }

        // Update doppelg√§nger segments in real time (mirrors current snake)
        if (state.doppelganger.active) {
          state.doppelganger.segments = computeMirrorSegments(state.snake);

          // Doppelg√§nger eats regular food (competes with the player!)
          const doppelHead = state.doppelganger.segments[0];
          if (state.food && doppelHead.x === state.food.x && doppelHead.y === state.food.y) {
            // Food is consumed but player gets NO points ‚Äî the doppelg√§nger stole it
            state.food = placeFood(state);
          }
        }

        return state;
      }

      // ============================================================
      // Rendering
      // ============================================================
      function render(state) {
        // Clear canvas
        ctx.fillStyle = '#111122';
        ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

        // Draw grid (subtle)
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= GRID_SIZE; i++) {
          ctx.beginPath();
          ctx.moveTo(i * CELL_SIZE, 0);
          ctx.lineTo(i * CELL_SIZE, CANVAS_SIZE);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i * CELL_SIZE);
          ctx.lineTo(CANVAS_SIZE, i * CELL_SIZE);
          ctx.stroke();
        }

        // Draw food
        if (state.food) {
          ctx.fillStyle = '#ff4444';
          ctx.shadowColor = '#ff4444';
          ctx.shadowBlur = 8;
          ctx.beginPath();
          ctx.arc(
            state.food.x * CELL_SIZE + CELL_SIZE / 2,
            state.food.y * CELL_SIZE + CELL_SIZE / 2,
            CELL_SIZE / 2 - 2,
            0, Math.PI * 2
          );
          ctx.fill();
          ctx.shadowBlur = 0;
        }

        // Draw mirror food (flashing cyan/magenta)
        if (state.mirrorFood) {
          const now = performance.now();
          const flashPhase = Math.sin(now / 150); // fast flash
          const alpha = 0.5 + 0.5 * Math.abs(flashPhase);
          const hue = flashPhase > 0 ? 280 : 190; // alternates magenta ‚Üî cyan
          ctx.fillStyle = `hsla(${hue}, 100%, 65%, ${alpha})`;
          ctx.shadowColor = hue === 280 ? '#cc44ff' : '#00ddff';
          ctx.shadowBlur = 12 + 6 * Math.abs(flashPhase);

          // Draw a diamond shape to distinguish from regular food
          const mx = state.mirrorFood.x * CELL_SIZE + CELL_SIZE / 2;
          const my = state.mirrorFood.y * CELL_SIZE + CELL_SIZE / 2;
          const r = CELL_SIZE / 2 - 1;
          ctx.beginPath();
          ctx.moveTo(mx, my - r);
          ctx.lineTo(mx + r, my);
          ctx.lineTo(mx, my + r);
          ctx.lineTo(mx - r, my);
          ctx.closePath();
          ctx.fill();

          // Inner glow circle
          ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + 0.3 * Math.abs(flashPhase)})`;
          ctx.beginPath();
          ctx.arc(mx, my, r / 3, 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowBlur = 0;
        }

        // Draw doppelg√§nger (ghostly mirror snake)
        if (state.doppelganger.active && state.doppelganger.segments.length > 0) {
          const remainRatio = state.doppelganger.totalDurationTicks > 0
            ? state.doppelganger.remainingTicks / state.doppelganger.totalDurationTicks
            : 1;
          // Fade out in the last 3 seconds
          const fadeAlpha = remainRatio < 0.2 ? remainRatio / 0.2 : 1;
          const pulseAlpha = 0.5 + 0.15 * Math.sin(performance.now() / 200);
          const baseAlpha = pulseAlpha * fadeAlpha;

          state.doppelganger.segments.forEach(function (segment, index) {
            if (index === 0) {
              // Doppelg√§nger head
              ctx.fillStyle = `rgba(200, 50, 255, ${baseAlpha})`;
              ctx.shadowColor = '#cc44ff';
              ctx.shadowBlur = 8;
            } else {
              // Doppelg√§nger body ‚Äî gradient from bright to dim
              const brightness = Math.max(30, 70 - index * 2);
              ctx.fillStyle = `hsla(280, 100%, ${brightness}%, ${baseAlpha * 0.85})`;
              ctx.shadowBlur = 0;
            }

            const padding = index === 0 ? 1 : 2;
            ctx.fillRect(
              segment.x * CELL_SIZE + padding,
              segment.y * CELL_SIZE + padding,
              CELL_SIZE - padding * 2,
              CELL_SIZE - padding * 2
            );
          });

          ctx.shadowBlur = 0;

          // Draw "MIRROR" indicator and timer
          const secondsLeft = Math.ceil(state.doppelganger.remainingTicks / TICK_RATE);
          ctx.fillStyle = `rgba(200, 50, 255, ${0.7 * fadeAlpha})`;
          ctx.font = 'bold 11px Arial';
          ctx.textAlign = 'left';
          ctx.fillText(`ü™û MIRROR ${secondsLeft}s`, 6, 14);
          // Double points indicator
          ctx.fillStyle = `rgba(255, 200, 0, ${0.8 * fadeAlpha})`;
          ctx.fillText('‚ö° 2√ó POINTS', 6, 28);
          ctx.textAlign = 'start';
        }

        // Draw snake
        state.snake.forEach(function (segment, index) {
          if (index === 0) {
            // Head
            ctx.fillStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 6;
          } else {
            // Body ‚Äî gradient from bright to dim
            const brightness = Math.max(40, 100 - index * 3);
            ctx.fillStyle = `hsl(150, 100%, ${brightness}%)`;
            ctx.shadowBlur = 0;
          }

          const padding = index === 0 ? 1 : 2;
          ctx.fillRect(
            segment.x * CELL_SIZE + padding,
            segment.y * CELL_SIZE + padding,
            CELL_SIZE - padding * 2,
            CELL_SIZE - padding * 2
          );
        });

        ctx.shadowBlur = 0;

        // Draw game over overlay
        if (state.gameOver) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
          ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
          ctx.fillStyle = '#ff4444';
          ctx.font = 'bold 36px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('GAME OVER', CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 10);
          ctx.fillStyle = '#ffaa00';
          ctx.font = '18px Arial';
          ctx.fillText(`Score: ${state.score}`, CANVAS_SIZE / 2, CANVAS_SIZE / 2 + 25);
          ctx.fillStyle = '#888';
          ctx.font = '14px Arial';
          ctx.fillText('Press R to restart', CANVAS_SIZE / 2, CANVAS_SIZE / 2 + 55);
        }

        // Update score display
        scoreDisplay.textContent = `Score: ${state.score}`;

        // Update message
        if (state.gameOver) {
          messageDisplay.textContent = 'Game Over! Press R to restart';
          messageDisplay.className = 'game-over';
        } else if (!state.started) {
          messageDisplay.textContent = 'Press any arrow key to start';
          messageDisplay.className = '';
        } else {
          let msg = `Move: ${state.moveCounter} | Direction: ${state.direction}`;
          if (state.doppelganger.active) {
            const secondsLeft = Math.ceil(state.doppelganger.remainingTicks / TICK_RATE);
            msg += ` | ü™û Mirror: ${secondsLeft}s (2√ó pts)`;
          } else if (state.mirrorFood) {
            msg += ' | üíé Mirror food on field!';
          }
          messageDisplay.textContent = msg;
          messageDisplay.className = '';
        }
      }

      // ============================================================
      // Input Handling
      // ============================================================
      const OPPOSITE = { up: 'down', down: 'up', left: 'right', right: 'left' };

      document.addEventListener('keydown', function (e) {
        if (e.key === 'r' || e.key === 'R') {
          state = createInitialState();
          state.food = placeFood(state);
          state.mirrorFoodSpawnInterval = getRandomMirrorFoodInterval();
          state.mirrorFoodTimer = state.mirrorFoodSpawnInterval;
          return;
        }

        const dirMap = {
          'ArrowUp': 'up',
          'ArrowDown': 'down',
          'ArrowLeft': 'left',
          'ArrowRight': 'right',
        };

        const newDir = dirMap[e.key];
        if (!newDir) return;

        e.preventDefault();

        if (!state.started) {
          state.started = true;
          // Food is already placed during initialization, no need to re-place
          state.nextDirection = newDir;
          // Don't allow starting in opposite of initial direction
          if (OPPOSITE[newDir] === state.direction) {
            state.nextDirection = state.direction;
          }
          return;
        }

        if (state.gameOver) return;

        // Prevent reversing into yourself
        if (OPPOSITE[newDir] !== state.direction) {
          state.nextDirection = newDir;
        }
      });

      // ============================================================
      // Game Loop
      // ============================================================
      function gameLoop(timestamp) {
        update(state);
        render(state);
        requestAnimationFrame(gameLoop);
      }

      // ============================================================
      // AI Debug Integration
      // ============================================================
      if (window.__AI_DEBUG__) {
        // Register state provider
        window.__AI_DEBUG__.registerStateProvider(
          function () { return state; },
          function (patch) {
            // Merge patch into state
            if (patch) {
              Object.keys(patch).forEach(function (key) {
                if (key === 'snake' || key === 'food') {
                  state[key] = JSON.parse(JSON.stringify(patch[key]));
                } else {
                  state[key] = patch[key];
                }
              });
            }
          }
        );

        // Register canvas for film strip
        window.__AI_DEBUG__.registerCanvas(canvas);

        console.log('%cüêç Snake game registered with FrameTape', 'color: #00ff88;');

        // Auto-activate AI debug mode via URL parameter ?debug=ai
        if (new URLSearchParams(window.location.search).get('debug') === 'ai') {
          window.__AI_DEBUG__.setMode('ai');
          console.log('%cü§ñ AI Debug Mode auto-activated via URL parameter', 'color: #00ff88; font-weight: bold;');
        }
      }

      // ============================================================
      // Initialize
      // ============================================================
      // Place initial food
      state.food = placeFood(state);

      // Initialize mirror food timer
      state.mirrorFoodSpawnInterval = getRandomMirrorFoodInterval();
      state.mirrorFoodTimer = state.mirrorFoodSpawnInterval;

      // Initial render
      render(state);

      // Start game loop
      requestAnimationFrame(gameLoop);

    })();
  </script>
</body>
</html>
